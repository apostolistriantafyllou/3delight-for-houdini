#include "utils.h"

surface hlight(
	color light_color = color(1),
	float light_intensity = 1,
	float light_exposure = 1,
	int normalizearea  = 1,
	int singlesided = 0,
	int reverse = 0,
	float _3dl_spread = 1,
	float _3dl_diffuse_contribution = 1,
	float _3dl_specular_contribution = 1,
	float _3dl_hair_contribution = 1,
	float _3dl_volume_contribution = 1,

	/* spot light */
	int coneenable = 0,
	float coneangle = 45,
	float conedelta = 10,
	string projmap = ""
)
{
	Ci = 0;

	/* So that area light doesn't cast any shadows. */
	if( !raytype("camera") )
	{
		Ci += transparent();
	}

	float scale = 1;
	color light_col = light_color;
	if( coneenable )
	{
		/* Cone and penumbra */
		float cosangle = abs( dot(-normalize(I), normalize(N)) );
		float _coneangle = radians(coneangle);
		float penumbraangle = radians(conedelta);

		float coslimit = cos(_coneangle / 2);
		float cospen = cos((_coneangle / 2) + penumbraangle);
		float low = min(cospen, coslimit);
		float high = max(cospen, coslimit);

		scale = M_PI * smoothstep(low, high, cosangle);
		scale /= surfacearea();

		if( projmap != "" )
		{
			point O = P - I;
			point localO = transform( "object", O );
			vector Iobj = localO - point(0);

			float s = Iobj[0] + 0.5;
			float t = Iobj[1] + 0.5;

			color tex_value = texture(
				projmap, s, t,
				"swrap", "clamp",
				"twrap", "clamp" );
			light_col = light_color * tex_value;
		}
	}
	else
	{
		/* all other lights */
		if( singlesided && backfacing() != reverse )
		{
			Ci = transparent();
			return;
		}

		if( normalizearea == 1 )
			scale /= surfacearea();
	}

	color result = light_col * light_intensity * pow(2, light_exposure);
	/*
		Conditions are arranged so that if 3Delight tags hair rays as
		specular we won't be scaling twice.
	*/
	if( _3dl_diffuse_contribution!=1.0 && raytype("diffuse") )
		result *= _3dl_diffuse_contribution;
	else if( _3dl_hair_contribution!=1.0 && raytype("hair") )
		result *= _3dl_hair_contribution;
	else if( _3dl_specular_contribution!=1.0 && raytype("specular") )
		result *= _3dl_specular_contribution;
	else if( _3dl_volume_contribution!=1.0 && raytype("volume") )
		result *= _3dl_volume_contribution;

	Ci += scale * result * emission( "focus",  spread_to_focus(_3dl_spread) );
}
